{"ast":null,"code":"import _get from \"C:/Source/Watts-Co-Toolbox/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:/Source/Watts-Co-Toolbox/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:/Source/Watts-Co-Toolbox/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/Source/Watts-Co-Toolbox/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"C:/Source/Watts-Co-Toolbox/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Source/Watts-Co-Toolbox/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ComponentFactoryResolver, Directive, EventEmitter, NgModule, Output, TemplateRef, ViewContainerRef } from '@angular/core';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * \\@docs-private\n * @return {?}\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nfunction throwNullPortalError() {\n  throw Error('Must provide a portal to attach');\n}\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction throwPortalAlreadyAttachedError() {\n  throw Error('Host already has a portal attached');\n}\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction throwPortalOutletAlreadyDisposedError() {\n  throw Error('This PortalOutlet has already been disposed');\n}\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction throwUnknownPortalTypeError() {\n  throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' + 'a ComponentPortal or a TemplatePortal.');\n}\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction throwNullPortalOutletError() {\n  throw Error('Attempting to attach a portal to a null PortalOutlet');\n}\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction throwNoPortalAttachedError() {\n  throw Error('Attempting to detach a portal that is not attached to a host');\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalOutlet`.\n * @abstract\n * @template T\n */\n\n\nvar Portal = /*#__PURE__*/function () {\n  function Portal() {\n    _classCallCheck(this, Portal);\n  }\n\n  _createClass(Portal, [{\n    key: \"attach\",\n\n    /**\n     * Attach this portal to a host.\n     * @param {?} host\n     * @return {?}\n     */\n    value: function attach(host) {\n      if (host == null) {\n        throwNullPortalOutletError();\n      }\n\n      if (host.hasAttached()) {\n        throwPortalAlreadyAttachedError();\n      }\n\n      this._attachedHost = host;\n      return (\n        /** @type {?} */\n        host.attach(this)\n      );\n    }\n    /**\n     * Detach this portal from its host\n     * @return {?}\n     */\n\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      /** @type {?} */\n      var host = this._attachedHost;\n\n      if (host == null) {\n        throwNoPortalAttachedError();\n      } else {\n        this._attachedHost = null;\n        host.detach();\n      }\n    }\n    /**\n     * Whether this portal is attached to a host.\n     * @return {?}\n     */\n\n  }, {\n    key: \"setAttachedHost\",\n\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     * @param {?} host\n     * @return {?}\n     */\n    value: function setAttachedHost(host) {\n      this._attachedHost = host;\n    }\n  }, {\n    key: \"isAttached\",\n    get: function get() {\n      return this._attachedHost != null;\n    }\n  }]);\n\n  return Portal;\n}();\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n * @template T\n */\n\n\nvar ComponentPortal = /*#__PURE__*/function (_Portal) {\n  _inherits(ComponentPortal, _Portal);\n\n  var _super = _createSuper(ComponentPortal);\n\n  /**\n   * @param {?} component\n   * @param {?=} viewContainerRef\n   * @param {?=} injector\n   * @param {?=} componentFactoryResolver\n   */\n  function ComponentPortal(component, viewContainerRef, injector, componentFactoryResolver) {\n    var _this;\n\n    _classCallCheck(this, ComponentPortal);\n\n    _this = _super.call(this);\n    _this.component = component;\n    _this.viewContainerRef = viewContainerRef;\n    _this.injector = injector;\n    _this.componentFactoryResolver = componentFactoryResolver;\n    return _this;\n  }\n\n  return ComponentPortal;\n}(Portal);\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n * @template C\n */\n\n\nvar TemplatePortal = /*#__PURE__*/function (_Portal2) {\n  _inherits(TemplatePortal, _Portal2);\n\n  var _super2 = _createSuper(TemplatePortal);\n\n  /**\n   * @param {?} template\n   * @param {?} viewContainerRef\n   * @param {?=} context\n   */\n  function TemplatePortal(template, viewContainerRef, context) {\n    var _this2;\n\n    _classCallCheck(this, TemplatePortal);\n\n    _this2 = _super2.call(this);\n    _this2.templateRef = template;\n    _this2.viewContainerRef = viewContainerRef;\n    _this2.context = context;\n    return _this2;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(TemplatePortal, [{\n    key: \"attach\",\n\n    /**\n     * Attach the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     * @param {?} host\n     * @param {?=} context\n     * @return {?}\n     */\n    value: function attach(host) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.context;\n      this.context = context;\n      return _get(_getPrototypeOf(TemplatePortal.prototype), \"attach\", this).call(this, host);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      this.context = undefined;\n      return _get(_getPrototypeOf(TemplatePortal.prototype), \"detach\", this).call(this);\n    }\n  }, {\n    key: \"origin\",\n    get: function get() {\n      return this.templateRef.elementRef;\n    }\n  }]);\n\n  return TemplatePortal;\n}(Portal);\n/**\n * Partial implementation of PortalOutlet that handles attaching\n * ComponentPortal and TemplatePortal.\n * @abstract\n */\n\n\nvar BasePortalOutlet = /*#__PURE__*/function () {\n  function BasePortalOutlet() {\n    _classCallCheck(this, BasePortalOutlet);\n\n    /**\n     * Whether this host has already been permanently disposed.\n     */\n    this._isDisposed = false;\n  }\n  /**\n   * Whether this host has an attached portal.\n   * @return {?}\n   */\n\n\n  _createClass(BasePortalOutlet, [{\n    key: \"hasAttached\",\n    value: function hasAttached() {\n      return !!this._attachedPortal;\n    }\n    /**\n     * Attaches a portal.\n     * @param {?} portal\n     * @return {?}\n     */\n\n  }, {\n    key: \"attach\",\n    value: function attach(portal) {\n      if (!portal) {\n        throwNullPortalError();\n      }\n\n      if (this.hasAttached()) {\n        throwPortalAlreadyAttachedError();\n      }\n\n      if (this._isDisposed) {\n        throwPortalOutletAlreadyDisposedError();\n      }\n\n      if (portal instanceof ComponentPortal) {\n        this._attachedPortal = portal;\n        return this.attachComponentPortal(portal);\n      } else if (portal instanceof TemplatePortal) {\n        this._attachedPortal = portal;\n        return this.attachTemplatePortal(portal);\n      }\n\n      throwUnknownPortalTypeError();\n    }\n    /**\n     * Detaches a previously attached portal.\n     * @return {?}\n     */\n\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      if (this._attachedPortal) {\n        this._attachedPortal.setAttachedHost(null);\n\n        this._attachedPortal = null;\n      }\n\n      this._invokeDisposeFn();\n    }\n    /**\n     * Permanently dispose of this portal host.\n     * @return {?}\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      if (this.hasAttached()) {\n        this.detach();\n      }\n\n      this._invokeDisposeFn();\n\n      this._isDisposed = true;\n    }\n    /**\n     * \\@docs-private\n     * @param {?} fn\n     * @return {?}\n     */\n\n  }, {\n    key: \"setDisposeFn\",\n    value: function setDisposeFn(fn) {\n      this._disposeFn = fn;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"_invokeDisposeFn\",\n    value: function _invokeDisposeFn() {\n      if (this._disposeFn) {\n        this._disposeFn();\n\n        this._disposeFn = null;\n      }\n    }\n  }]);\n\n  return BasePortalOutlet;\n}();\n/**\n * @deprecated Use `BasePortalOutlet` instead.\n * \\@breaking-change 9.0.0\n * @abstract\n */\n\n\nvar BasePortalHost = /*#__PURE__*/function (_BasePortalOutlet) {\n  _inherits(BasePortalHost, _BasePortalOutlet);\n\n  var _super3 = _createSuper(BasePortalHost);\n\n  function BasePortalHost() {\n    _classCallCheck(this, BasePortalHost);\n\n    return _super3.apply(this, arguments);\n  }\n\n  return BasePortalHost;\n}(BasePortalOutlet);\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n */\n\n\nvar DomPortalOutlet = /*#__PURE__*/function (_BasePortalOutlet2) {\n  _inherits(DomPortalOutlet, _BasePortalOutlet2);\n\n  var _super4 = _createSuper(DomPortalOutlet);\n\n  /**\n   * @param {?} outletElement\n   * @param {?} _componentFactoryResolver\n   * @param {?} _appRef\n   * @param {?} _defaultInjector\n   */\n  function DomPortalOutlet(outletElement, _componentFactoryResolver, _appRef, _defaultInjector) {\n    var _this3;\n\n    _classCallCheck(this, DomPortalOutlet);\n\n    _this3 = _super4.call(this);\n    _this3.outletElement = outletElement;\n    _this3._componentFactoryResolver = _componentFactoryResolver;\n    _this3._appRef = _appRef;\n    _this3._defaultInjector = _defaultInjector;\n    return _this3;\n  }\n  /**\n   * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n   * @template T\n   * @param {?} portal Portal to be attached\n   * @return {?} Reference to the created component.\n   */\n\n\n  _createClass(DomPortalOutlet, [{\n    key: \"attachComponentPortal\",\n    value: function attachComponentPortal(portal) {\n      var _this4 = this;\n\n      /** @type {?} */\n      var resolver = portal.componentFactoryResolver || this._componentFactoryResolver;\n      /** @type {?} */\n\n      var componentFactory = resolver.resolveComponentFactory(portal.component);\n      /** @type {?} */\n\n      var componentRef; // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n      // for the component (in terms of Angular's component tree, not rendering).\n      // When the ViewContainerRef is missing, we use the factory to create the component directly\n      // and then manually attach the view to the application.\n\n      if (portal.viewContainerRef) {\n        componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.injector);\n        this.setDisposeFn(\n        /**\n        * @return {?}\n        */\n        function () {\n          return componentRef.destroy();\n        });\n      } else {\n        componentRef = componentFactory.create(portal.injector || this._defaultInjector);\n\n        this._appRef.attachView(componentRef.hostView);\n\n        this.setDisposeFn(\n        /**\n        * @return {?}\n        */\n        function () {\n          _this4._appRef.detachView(componentRef.hostView);\n\n          componentRef.destroy();\n        });\n      } // At this point the component has been instantiated, so we move it to the location in the DOM\n      // where we want it to be rendered.\n\n\n      this.outletElement.appendChild(this._getComponentRootNode(componentRef));\n      return componentRef;\n    }\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n\n  }, {\n    key: \"attachTemplatePortal\",\n    value: function attachTemplatePortal(portal) {\n      var _this5 = this;\n\n      /** @type {?} */\n      var viewContainer = portal.viewContainerRef;\n      /** @type {?} */\n\n      var viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);\n      viewRef.detectChanges(); // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n      // But for the DomPortalOutlet the view can be added everywhere in the DOM\n      // (e.g Overlay Container) To move the view to the specified host element. We just\n      // re-append the existing root nodes.\n\n      viewRef.rootNodes.forEach(\n      /**\n      * @param {?} rootNode\n      * @return {?}\n      */\n      function (rootNode) {\n        return _this5.outletElement.appendChild(rootNode);\n      });\n      this.setDisposeFn(\n      /**\n      * @return {?}\n      */\n      function () {\n        /** @type {?} */\n        var index = viewContainer.indexOf(viewRef);\n\n        if (index !== -1) {\n          viewContainer.remove(index);\n        }\n      }); // TODO(jelbourn): Return locals from view.\n\n      return viewRef;\n    }\n    /**\n     * Clears out a portal from the DOM.\n     * @return {?}\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(DomPortalOutlet.prototype), \"dispose\", this).call(this);\n\n      if (this.outletElement.parentNode != null) {\n        this.outletElement.parentNode.removeChild(this.outletElement);\n      }\n    }\n    /**\n     * Gets the root HTMLElement for an instantiated component.\n     * @private\n     * @param {?} componentRef\n     * @return {?}\n     */\n\n  }, {\n    key: \"_getComponentRootNode\",\n    value: function _getComponentRootNode(componentRef) {\n      return (\n        /** @type {?} */\n\n        /** @type {?} */\n        componentRef.hostView.rootNodes[0]\n      );\n    }\n  }]);\n\n  return DomPortalOutlet;\n}(BasePortalOutlet);\n/**\n * @deprecated Use `DomPortalOutlet` instead.\n * \\@breaking-change 9.0.0\n */\n\n\nvar DomPortalHost = /*#__PURE__*/function (_DomPortalOutlet) {\n  _inherits(DomPortalHost, _DomPortalOutlet);\n\n  var _super5 = _createSuper(DomPortalHost);\n\n  function DomPortalHost() {\n    _classCallCheck(this, DomPortalHost);\n\n    return _super5.apply(this, arguments);\n  }\n\n  return DomPortalHost;\n}(DomPortalOutlet);\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\n */\n\n\nvar CdkPortal = /*#__PURE__*/function (_TemplatePortal) {\n  _inherits(CdkPortal, _TemplatePortal);\n\n  var _super6 = _createSuper(CdkPortal);\n\n  /**\n   * @param {?} templateRef\n   * @param {?} viewContainerRef\n   */\n  function CdkPortal(templateRef, viewContainerRef) {\n    _classCallCheck(this, CdkPortal);\n\n    return _super6.call(this, templateRef, viewContainerRef);\n  }\n\n  return CdkPortal;\n}(TemplatePortal);\n\nCdkPortal.ɵfac = function CdkPortal_Factory(t) {\n  return new (t || CdkPortal)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n};\n\nCdkPortal.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: CdkPortal,\n  selectors: [[\"\", \"cdkPortal\", \"\"]],\n  exportAs: [\"cdkPortal\"],\n  features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n});\n/** @nocollapse */\n\nCdkPortal.ctorParameters = function () {\n  return [{\n    type: TemplateRef\n  }, {\n    type: ViewContainerRef\n  }];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkPortal, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkPortal]',\n      exportAs: 'cdkPortal'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.TemplateRef\n    }, {\n      type: ɵngcc0.ViewContainerRef\n    }];\n  }, null);\n})();\n/**\n * @deprecated Use `CdkPortal` instead.\n * \\@breaking-change 9.0.0\n */\n\n\nvar TemplatePortalDirective = /*#__PURE__*/function (_CdkPortal) {\n  _inherits(TemplatePortalDirective, _CdkPortal);\n\n  var _super7 = _createSuper(TemplatePortalDirective);\n\n  function TemplatePortalDirective() {\n    _classCallCheck(this, TemplatePortalDirective);\n\n    return _super7.apply(this, arguments);\n  }\n\n  return TemplatePortalDirective;\n}(CdkPortal);\n\nTemplatePortalDirective.ɵfac = function TemplatePortalDirective_Factory(t) {\n  return ɵTemplatePortalDirective_BaseFactory(t || TemplatePortalDirective);\n};\n\nTemplatePortalDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: TemplatePortalDirective,\n  selectors: [[\"\", \"cdk-portal\", \"\"], [\"\", \"portal\", \"\"]],\n  exportAs: [\"cdkPortal\"],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: CdkPortal,\n    useExisting: TemplatePortalDirective\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature]\n});\nvar ɵTemplatePortalDirective_BaseFactory = /*@__PURE__*/ɵngcc0.ɵɵgetInheritedFactory(TemplatePortalDirective);\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TemplatePortalDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[cdk-portal], [portal]',\n      exportAs: 'cdkPortal',\n      providers: [{\n        provide: CdkPortal,\n        useExisting: TemplatePortalDirective\n      }]\n    }]\n  }], null, null);\n})();\n/**\n * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be\n * directly attached to it, enabling declarative use.\n *\n * Usage:\n * `<ng-template [cdkPortalOutlet]=\"greeting\"></ng-template>`\n */\n\n\nvar CdkPortalOutlet = /*#__PURE__*/function (_BasePortalOutlet3) {\n  _inherits(CdkPortalOutlet, _BasePortalOutlet3);\n\n  var _super8 = _createSuper(CdkPortalOutlet);\n\n  /**\n   * @param {?} _componentFactoryResolver\n   * @param {?} _viewContainerRef\n   */\n  function CdkPortalOutlet(_componentFactoryResolver, _viewContainerRef) {\n    var _this6;\n\n    _classCallCheck(this, CdkPortalOutlet);\n\n    _this6 = _super8.call(this);\n    _this6._componentFactoryResolver = _componentFactoryResolver;\n    _this6._viewContainerRef = _viewContainerRef;\n    /**\n     * Whether the portal component is initialized.\n     */\n\n    _this6._isInitialized = false;\n    /**\n     * Emits when a portal is attached to the outlet.\n     */\n\n    _this6.attached = new EventEmitter();\n    return _this6;\n  }\n  /**\n   * Portal associated with the Portal outlet.\n   * @return {?}\n   */\n\n\n  _createClass(CdkPortalOutlet, [{\n    key: \"ngOnInit\",\n\n    /**\n     * @return {?}\n     */\n    value: function ngOnInit() {\n      this._isInitialized = true;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      _get(_getPrototypeOf(CdkPortalOutlet.prototype), \"dispose\", this).call(this);\n\n      this._attachedPortal = null;\n      this._attachedRef = null;\n    }\n    /**\n     * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n     *\n     * @template T\n     * @param {?} portal Portal to be attached to the portal outlet.\n     * @return {?} Reference to the created component.\n     */\n\n  }, {\n    key: \"attachComponentPortal\",\n    value: function attachComponentPortal(portal) {\n      portal.setAttachedHost(this); // If the portal specifies an origin, use that as the logical location of the component\n      // in the application tree. Otherwise use the location of this PortalOutlet.\n\n      /** @type {?} */\n\n      var viewContainerRef = portal.viewContainerRef != null ? portal.viewContainerRef : this._viewContainerRef;\n      /** @type {?} */\n\n      var resolver = portal.componentFactoryResolver || this._componentFactoryResolver;\n      /** @type {?} */\n\n      var componentFactory = resolver.resolveComponentFactory(portal.component);\n      /** @type {?} */\n\n      var ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.injector);\n\n      _get(_getPrototypeOf(CdkPortalOutlet.prototype), \"setDisposeFn\", this).call(this,\n      /**\n      * @return {?}\n      */\n      function () {\n        return ref.destroy();\n      });\n\n      this._attachedPortal = portal;\n      this._attachedRef = ref;\n      this.attached.emit(ref);\n      return ref;\n    }\n    /**\n     * Attach the given TemplatePortal to this PortlHost as an embedded View.\n     * @template C\n     * @param {?} portal Portal to be attached.\n     * @return {?} Reference to the created embedded view.\n     */\n\n  }, {\n    key: \"attachTemplatePortal\",\n    value: function attachTemplatePortal(portal) {\n      var _this7 = this;\n\n      portal.setAttachedHost(this);\n      /** @type {?} */\n\n      var viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);\n\n      _get(_getPrototypeOf(CdkPortalOutlet.prototype), \"setDisposeFn\", this).call(this,\n      /**\n      * @return {?}\n      */\n      function () {\n        return _this7._viewContainerRef.clear();\n      });\n\n      this._attachedPortal = portal;\n      this._attachedRef = viewRef;\n      this.attached.emit(viewRef);\n      return viewRef;\n    }\n  }, {\n    key: \"portal\",\n    get: function get() {\n      return this._attachedPortal;\n    }\n    /**\n     * @param {?} portal\n     * @return {?}\n     */\n    ,\n    set: function set(portal) {\n      // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have\n      // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`\n      // and attach a portal programmatically in the parent component. When Angular does the first CD\n      // round, it will fire the setter with empty string, causing the user's content to be cleared.\n      if (this.hasAttached() && !portal && !this._isInitialized) {\n        return;\n      }\n\n      if (this.hasAttached()) {\n        _get(_getPrototypeOf(CdkPortalOutlet.prototype), \"detach\", this).call(this);\n      }\n\n      if (portal) {\n        _get(_getPrototypeOf(CdkPortalOutlet.prototype), \"attach\", this).call(this, portal);\n      }\n\n      this._attachedPortal = portal;\n    }\n    /**\n     * Component or view reference that is attached to the portal.\n     * @return {?}\n     */\n\n  }, {\n    key: \"attachedRef\",\n    get: function get() {\n      return this._attachedRef;\n    }\n  }]);\n\n  return CdkPortalOutlet;\n}(BasePortalOutlet);\n\nCdkPortalOutlet.ɵfac = function CdkPortalOutlet_Factory(t) {\n  return new (t || CdkPortalOutlet)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n};\n\nCdkPortalOutlet.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: CdkPortalOutlet,\n  selectors: [[\"\", \"cdkPortalOutlet\", \"\"]],\n  inputs: {\n    portal: [\"cdkPortalOutlet\", \"portal\"]\n  },\n  outputs: {\n    attached: \"attached\"\n  },\n  exportAs: [\"cdkPortalOutlet\"],\n  features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n});\n/** @nocollapse */\n\nCdkPortalOutlet.ctorParameters = function () {\n  return [{\n    type: ComponentFactoryResolver\n  }, {\n    type: ViewContainerRef\n  }];\n};\n\nCdkPortalOutlet.propDecorators = {\n  attached: [{\n    type: Output\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CdkPortalOutlet, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkPortalOutlet]',\n      exportAs: 'cdkPortalOutlet',\n      inputs: ['portal: cdkPortalOutlet']\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ComponentFactoryResolver\n    }, {\n      type: ɵngcc0.ViewContainerRef\n    }];\n  }, {\n    attached: [{\n      type: Output\n    }]\n  });\n})();\n/**\n * @deprecated Use `CdkPortalOutlet` instead.\n * \\@breaking-change 9.0.0\n */\n\n\nvar PortalHostDirective = /*#__PURE__*/function (_CdkPortalOutlet) {\n  _inherits(PortalHostDirective, _CdkPortalOutlet);\n\n  var _super9 = _createSuper(PortalHostDirective);\n\n  function PortalHostDirective() {\n    _classCallCheck(this, PortalHostDirective);\n\n    return _super9.apply(this, arguments);\n  }\n\n  return PortalHostDirective;\n}(CdkPortalOutlet);\n\nPortalHostDirective.ɵfac = function PortalHostDirective_Factory(t) {\n  return ɵPortalHostDirective_BaseFactory(t || PortalHostDirective);\n};\n\nPortalHostDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: PortalHostDirective,\n  selectors: [[\"\", \"cdkPortalHost\", \"\"], [\"\", \"portalHost\", \"\"]],\n  inputs: {\n    portal: [\"cdkPortalHost\", \"portal\"]\n  },\n  exportAs: [\"cdkPortalHost\"],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: CdkPortalOutlet,\n    useExisting: PortalHostDirective\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature]\n});\nvar ɵPortalHostDirective_BaseFactory = /*@__PURE__*/ɵngcc0.ɵɵgetInheritedFactory(PortalHostDirective);\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PortalHostDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkPortalHost], [portalHost]',\n      exportAs: 'cdkPortalHost',\n      inputs: ['portal: cdkPortalHost'],\n      providers: [{\n        provide: CdkPortalOutlet,\n        useExisting: PortalHostDirective\n      }]\n    }]\n  }], null, null);\n})();\n\nvar PortalModule = function PortalModule() {\n  _classCallCheck(this, PortalModule);\n};\n\nPortalModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: PortalModule\n});\nPortalModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  factory: function PortalModule_Factory(t) {\n    return new (t || PortalModule)();\n  }\n});\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(PortalModule, {\n    declarations: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],\n    exports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective]\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PortalModule, [{\n    type: NgModule,\n    args: [{\n      exports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],\n      declarations: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective]\n    }]\n  }], null, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * \\@docs-private\n */\n\n\nvar PortalInjector = /*#__PURE__*/function () {\n  /**\n   * @param {?} _parentInjector\n   * @param {?} _customTokens\n   */\n  function PortalInjector(_parentInjector, _customTokens) {\n    _classCallCheck(this, PortalInjector);\n\n    this._parentInjector = _parentInjector;\n    this._customTokens = _customTokens;\n  }\n  /**\n   * @param {?} token\n   * @param {?=} notFoundValue\n   * @return {?}\n   */\n\n\n  _createClass(PortalInjector, [{\n    key: \"get\",\n    value: function get(token, notFoundValue) {\n      /** @type {?} */\n      var value = this._customTokens.get(token);\n\n      if (typeof value !== 'undefined') {\n        return value;\n      }\n\n      return this._parentInjector.get(token, notFoundValue);\n    }\n  }]);\n\n  return PortalInjector;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { Portal, ComponentPortal, TemplatePortal, BasePortalOutlet, BasePortalHost, DomPortalOutlet, DomPortalHost, CdkPortal, TemplatePortalDirective, CdkPortalOutlet, PortalHostDirective, PortalModule, PortalInjector };","map":{"version":3,"sources":["../../../src/cdk/portal/portal-errors.ts","../../../src/cdk/portal/portal.ts","../../../src/cdk/portal/dom-portal-outlet.ts","../../../src/cdk/portal/portal-directives.ts","../../../src/cdk/portal/portal-injector.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * @docs-private\n */\nexport function throwNullPortalError() {\n  throw Error('Must provide a portal to attach');\n}\n\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * @docs-private\n */\nexport function throwPortalAlreadyAttachedError() {\n  throw Error('Host already has a portal attached');\n}\n\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * @docs-private\n */\nexport function throwPortalOutletAlreadyDisposedError() {\n  throw Error('This PortalOutlet has already been disposed');\n}\n\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * @docs-private\n */\nexport function throwUnknownPortalTypeError() {\n  throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' +\n              'a ComponentPortal or a TemplatePortal.');\n}\n\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * @docs-private\n */\nexport function throwNullPortalOutletError() {\n  throw Error('Attempting to attach a portal to a null PortalOutlet');\n}\n\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * @docs-private\n */\nexport function throwNoPortalAttachedError() {\n  throw Error('Attempting to detach a portal that is not attached to a host');\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n    TemplateRef,\n    ViewContainerRef,\n    ElementRef,\n    ComponentRef,\n    EmbeddedViewRef,\n    Injector,\n    ComponentFactoryResolver,\n} from '@angular/core';\nimport {\n    throwNullPortalOutletError,\n    throwPortalAlreadyAttachedError,\n    throwNoPortalAttachedError,\n    throwNullPortalError,\n    throwPortalOutletAlreadyDisposedError,\n    throwUnknownPortalTypeError\n} from './portal-errors';\n\n/** Interface that can be used to generically type a class. */\nexport interface ComponentType<T> {\n  new (...args: any[]): T;\n}\n\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalOutlet`.\n */\nexport abstract class Portal<T> {\n  private _attachedHost: PortalOutlet | null;\n\n  /** Attach this portal to a host. */\n  attach(host: PortalOutlet): T {\n    if (host == null) {\n      throwNullPortalOutletError();\n    }\n\n    if (host.hasAttached()) {\n      throwPortalAlreadyAttachedError();\n    }\n\n    this._attachedHost = host;\n    return <T> host.attach(this);\n  }\n\n  /** Detach this portal from its host */\n  detach(): void {\n    let host = this._attachedHost;\n\n    if (host == null) {\n      throwNoPortalAttachedError();\n    } else {\n      this._attachedHost = null;\n      host.detach();\n    }\n  }\n\n  /** Whether this portal is attached to a host. */\n  get isAttached(): boolean {\n    return this._attachedHost != null;\n  }\n\n  /**\n   * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n   * the PortalOutlet when it is performing an `attach()` or `detach()`.\n   */\n  setAttachedHost(host: PortalOutlet | null) {\n    this._attachedHost = host;\n  }\n}\n\n\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n */\nexport class ComponentPortal<T> extends Portal<ComponentRef<T>> {\n  /** The type of the component that will be instantiated for attachment. */\n  component: ComponentType<T>;\n\n  /**\n   * [Optional] Where the attached component should live in Angular's *logical* component tree.\n   * This is different from where the component *renders*, which is determined by the PortalOutlet.\n   * The origin is necessary when the host is outside of the Angular application context.\n   */\n  viewContainerRef?: ViewContainerRef | null;\n\n  /** [Optional] Injector used for the instantiation of the component. */\n  injector?: Injector | null;\n\n  /**\n   * Alternate `ComponentFactoryResolver` to use when resolving the associated component.\n   * Defaults to using the resolver from the outlet that the portal is attached to.\n   */\n  componentFactoryResolver?: ComponentFactoryResolver | null;\n\n  constructor(\n      component: ComponentType<T>,\n      viewContainerRef?: ViewContainerRef | null,\n      injector?: Injector | null,\n      componentFactoryResolver?: ComponentFactoryResolver | null) {\n    super();\n    this.component = component;\n    this.viewContainerRef = viewContainerRef;\n    this.injector = injector;\n    this.componentFactoryResolver = componentFactoryResolver;\n  }\n}\n\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n */\nexport class TemplatePortal<C = any> extends Portal<EmbeddedViewRef<C>> {\n  /** The embedded template that will be used to instantiate an embedded View in the host. */\n  templateRef: TemplateRef<C>;\n\n  /** Reference to the ViewContainer into which the template will be stamped out. */\n  viewContainerRef: ViewContainerRef;\n\n  /** Contextual data to be passed in to the embedded view. */\n  context: C | undefined;\n\n  constructor(template: TemplateRef<C>, viewContainerRef: ViewContainerRef, context?: C) {\n    super();\n    this.templateRef = template;\n    this.viewContainerRef = viewContainerRef;\n    this.context = context;\n  }\n\n  get origin(): ElementRef {\n    return this.templateRef.elementRef;\n  }\n\n  /**\n   * Attach the portal to the provided `PortalOutlet`.\n   * When a context is provided it will override the `context` property of the `TemplatePortal`\n   * instance.\n   */\n  attach(host: PortalOutlet, context: C | undefined = this.context): EmbeddedViewRef<C> {\n    this.context = context;\n    return super.attach(host);\n  }\n\n  detach(): void {\n    this.context = undefined;\n    return super.detach();\n  }\n}\n\n\n/** A `PortalOutlet` is an space that can contain a single `Portal`. */\nexport interface PortalOutlet {\n  /** Attaches a portal to this outlet. */\n  attach(portal: Portal<any>): any;\n\n  /** Detaches the currently attached portal from this outlet. */\n  detach(): any;\n\n  /** Performs cleanup before the outlet is destroyed. */\n  dispose(): void;\n\n  /** Whether there is currently a portal attached to this outlet. */\n  hasAttached(): boolean;\n}\n\n/**\n * @deprecated Use `PortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nexport type PortalHost = PortalOutlet;\n\n/**\n * Partial implementation of PortalOutlet that handles attaching\n * ComponentPortal and TemplatePortal.\n */\nexport abstract class BasePortalOutlet implements PortalOutlet {\n  /** The portal currently attached to the host. */\n  protected _attachedPortal: Portal<any> | null;\n\n  /** A function that will permanently dispose this host. */\n  private _disposeFn: (() => void) | null;\n\n  /** Whether this host has already been permanently disposed. */\n  private _isDisposed: boolean = false;\n\n  /** Whether this host has an attached portal. */\n  hasAttached(): boolean {\n    return !!this._attachedPortal;\n  }\n\n  attach<T>(portal: ComponentPortal<T>): ComponentRef<T>;\n  attach<T>(portal: TemplatePortal<T>): EmbeddedViewRef<T>;\n  attach(portal: any): any;\n\n  /** Attaches a portal. */\n  attach(portal: Portal<any>): any {\n    if (!portal) {\n      throwNullPortalError();\n    }\n\n    if (this.hasAttached()) {\n      throwPortalAlreadyAttachedError();\n    }\n\n    if (this._isDisposed) {\n      throwPortalOutletAlreadyDisposedError();\n    }\n\n    if (portal instanceof ComponentPortal) {\n      this._attachedPortal = portal;\n      return this.attachComponentPortal(portal);\n    } else if (portal instanceof TemplatePortal) {\n      this._attachedPortal = portal;\n      return this.attachTemplatePortal(portal);\n    }\n\n    throwUnknownPortalTypeError();\n  }\n\n  abstract attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T>;\n\n  abstract attachTemplatePortal<C>(portal: TemplatePortal<C>): EmbeddedViewRef<C>;\n\n  /** Detaches a previously attached portal. */\n  detach(): void {\n    if (this._attachedPortal) {\n      this._attachedPortal.setAttachedHost(null);\n      this._attachedPortal = null;\n    }\n\n    this._invokeDisposeFn();\n  }\n\n  /** Permanently dispose of this portal host. */\n  dispose(): void {\n    if (this.hasAttached()) {\n      this.detach();\n    }\n\n    this._invokeDisposeFn();\n    this._isDisposed = true;\n  }\n\n  /** @docs-private */\n  setDisposeFn(fn: () => void) {\n    this._disposeFn = fn;\n  }\n\n  private _invokeDisposeFn() {\n    if (this._disposeFn) {\n      this._disposeFn();\n      this._disposeFn = null;\n    }\n  }\n}\n\n/**\n * @deprecated Use `BasePortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nexport abstract class BasePortalHost extends BasePortalOutlet {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  ComponentFactoryResolver,\n  ComponentRef,\n  EmbeddedViewRef,\n  ApplicationRef,\n  Injector,\n} from '@angular/core';\nimport {BasePortalOutlet, ComponentPortal, TemplatePortal} from './portal';\n\n\n/**\n * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n */\nexport class DomPortalOutlet extends BasePortalOutlet {\n  constructor(\n      /** Element into which the content is projected. */\n      public outletElement: Element,\n      private _componentFactoryResolver: ComponentFactoryResolver,\n      private _appRef: ApplicationRef,\n      private _defaultInjector: Injector) {\n    super();\n  }\n\n  /**\n   * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n   * @param portal Portal to be attached\n   * @returns Reference to the created component.\n   */\n  attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T> {\n    const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;\n    const componentFactory = resolver.resolveComponentFactory(portal.component);\n    let componentRef: ComponentRef<T>;\n\n    // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n    // for the component (in terms of Angular's component tree, not rendering).\n    // When the ViewContainerRef is missing, we use the factory to create the component directly\n    // and then manually attach the view to the application.\n    if (portal.viewContainerRef) {\n      componentRef = portal.viewContainerRef.createComponent(\n          componentFactory,\n          portal.viewContainerRef.length,\n          portal.injector || portal.viewContainerRef.injector);\n\n      this.setDisposeFn(() => componentRef.destroy());\n    } else {\n      componentRef = componentFactory.create(portal.injector || this._defaultInjector);\n      this._appRef.attachView(componentRef.hostView);\n      this.setDisposeFn(() => {\n        this._appRef.detachView(componentRef.hostView);\n        componentRef.destroy();\n      });\n    }\n    // At this point the component has been instantiated, so we move it to the location in the DOM\n    // where we want it to be rendered.\n    this.outletElement.appendChild(this._getComponentRootNode(componentRef));\n\n    return componentRef;\n  }\n\n  /**\n   * Attaches a template portal to the DOM as an embedded view.\n   * @param portal Portal to be attached.\n   * @returns Reference to the created embedded view.\n   */\n  attachTemplatePortal<C>(portal: TemplatePortal<C>): EmbeddedViewRef<C> {\n    let viewContainer = portal.viewContainerRef;\n    let viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);\n    viewRef.detectChanges();\n\n    // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n    // But for the DomPortalOutlet the view can be added everywhere in the DOM\n    // (e.g Overlay Container) To move the view to the specified host element. We just\n    // re-append the existing root nodes.\n    viewRef.rootNodes.forEach(rootNode => this.outletElement.appendChild(rootNode));\n\n    this.setDisposeFn((() => {\n      let index = viewContainer.indexOf(viewRef);\n      if (index !== -1) {\n        viewContainer.remove(index);\n      }\n    }));\n\n    // TODO(jelbourn): Return locals from view.\n    return viewRef;\n  }\n\n  /**\n   * Clears out a portal from the DOM.\n   */\n  dispose(): void {\n    super.dispose();\n    if (this.outletElement.parentNode != null) {\n      this.outletElement.parentNode.removeChild(this.outletElement);\n    }\n  }\n\n  /** Gets the root HTMLElement for an instantiated component. */\n  private _getComponentRootNode(componentRef: ComponentRef<any>): HTMLElement {\n    return (componentRef.hostView as EmbeddedViewRef<any>).rootNodes[0] as HTMLElement;\n  }\n}\n\n/**\n * @deprecated Use `DomPortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nexport class DomPortalHost extends DomPortalOutlet {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  ComponentFactoryResolver,\n  ComponentRef,\n  Directive,\n  EmbeddedViewRef,\n  EventEmitter,\n  NgModule,\n  OnDestroy,\n  OnInit,\n  Output,\n  TemplateRef,\n  ViewContainerRef,\n} from '@angular/core';\nimport {BasePortalOutlet, ComponentPortal, Portal, TemplatePortal} from './portal';\n\n\n/**\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\n */\n@Directive({\n  selector: '[cdkPortal]',\n  exportAs: 'cdkPortal',\n})\nexport class CdkPortal extends TemplatePortal {\n  constructor(templateRef: TemplateRef<any>, viewContainerRef: ViewContainerRef) {\n    super(templateRef, viewContainerRef);\n  }\n}\n\n/**\n * @deprecated Use `CdkPortal` instead.\n * @breaking-change 9.0.0\n */\n@Directive({\n  selector: '[cdk-portal], [portal]',\n  exportAs: 'cdkPortal',\n  providers: [{\n    provide: CdkPortal,\n    useExisting: TemplatePortalDirective\n  }]\n})\nexport class TemplatePortalDirective extends CdkPortal {}\n\n/**\n * Possible attached references to the CdkPortalOutlet.\n */\nexport type CdkPortalOutletAttachedRef = ComponentRef<any> | EmbeddedViewRef<any> | null;\n\n\n/**\n * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be\n * directly attached to it, enabling declarative use.\n *\n * Usage:\n * `<ng-template [cdkPortalOutlet]=\"greeting\"></ng-template>`\n */\n@Directive({\n  selector: '[cdkPortalOutlet]',\n  exportAs: 'cdkPortalOutlet',\n  inputs: ['portal: cdkPortalOutlet']\n})\nexport class CdkPortalOutlet extends BasePortalOutlet implements OnInit, OnDestroy {\n  /** Whether the portal component is initialized. */\n  private _isInitialized = false;\n\n  /** Reference to the currently-attached component/view ref. */\n  private _attachedRef: CdkPortalOutletAttachedRef;\n\n  constructor(\n      private _componentFactoryResolver: ComponentFactoryResolver,\n      private _viewContainerRef: ViewContainerRef) {\n    super();\n  }\n\n  /** Portal associated with the Portal outlet. */\n  get portal(): Portal<any> | null {\n    return this._attachedPortal;\n  }\n\n  set portal(portal: Portal<any> | null) {\n    // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have\n    // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`\n    // and attach a portal programmatically in the parent component. When Angular does the first CD\n    // round, it will fire the setter with empty string, causing the user's content to be cleared.\n    if (this.hasAttached() && !portal && !this._isInitialized) {\n      return;\n    }\n\n    if (this.hasAttached()) {\n      super.detach();\n    }\n\n    if (portal) {\n      super.attach(portal);\n    }\n\n    this._attachedPortal = portal;\n  }\n\n  /** Emits when a portal is attached to the outlet. */\n  @Output() attached: EventEmitter<CdkPortalOutletAttachedRef> =\n      new EventEmitter<CdkPortalOutletAttachedRef>();\n\n  /** Component or view reference that is attached to the portal. */\n  get attachedRef(): CdkPortalOutletAttachedRef {\n    return this._attachedRef;\n  }\n\n  ngOnInit() {\n    this._isInitialized = true;\n  }\n\n  ngOnDestroy() {\n    super.dispose();\n    this._attachedPortal = null;\n    this._attachedRef = null;\n  }\n\n  /**\n   * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n   *\n   * @param portal Portal to be attached to the portal outlet.\n   * @returns Reference to the created component.\n   */\n  attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T> {\n    portal.setAttachedHost(this);\n\n    // If the portal specifies an origin, use that as the logical location of the component\n    // in the application tree. Otherwise use the location of this PortalOutlet.\n    const viewContainerRef = portal.viewContainerRef != null ?\n        portal.viewContainerRef :\n        this._viewContainerRef;\n\n    const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;\n    const componentFactory = resolver.resolveComponentFactory(portal.component);\n    const ref = viewContainerRef.createComponent(\n        componentFactory, viewContainerRef.length,\n        portal.injector || viewContainerRef.injector);\n\n    super.setDisposeFn(() => ref.destroy());\n    this._attachedPortal = portal;\n    this._attachedRef = ref;\n    this.attached.emit(ref);\n\n    return ref;\n  }\n\n  /**\n   * Attach the given TemplatePortal to this PortlHost as an embedded View.\n   * @param portal Portal to be attached.\n   * @returns Reference to the created embedded view.\n   */\n  attachTemplatePortal<C>(portal: TemplatePortal<C>): EmbeddedViewRef<C> {\n    portal.setAttachedHost(this);\n    const viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);\n    super.setDisposeFn(() => this._viewContainerRef.clear());\n\n    this._attachedPortal = portal;\n    this._attachedRef = viewRef;\n    this.attached.emit(viewRef);\n\n    return viewRef;\n  }\n}\n\n/**\n * @deprecated Use `CdkPortalOutlet` instead.\n * @breaking-change 9.0.0\n */\n@Directive({\n  selector: '[cdkPortalHost], [portalHost]',\n  exportAs: 'cdkPortalHost',\n  inputs: ['portal: cdkPortalHost'],\n  providers: [{\n    provide: CdkPortalOutlet,\n    useExisting: PortalHostDirective\n  }]\n})\nexport class PortalHostDirective extends CdkPortalOutlet {}\n\n\n@NgModule({\n  exports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],\n  declarations: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],\n})\nexport class PortalModule {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '@angular/core';\n\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * @docs-private\n */\nexport class PortalInjector implements Injector {\n  constructor(\n    private _parentInjector: Injector,\n    private _customTokens: WeakMap<any, any>) { }\n\n  get(token: any, notFoundValue?: any): any {\n    const value = this._customTokens.get(token);\n\n    if (typeof value !== 'undefined') {\n      return value;\n    }\n\n    return this._parentInjector.get<any>(token, notFoundValue);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}